/* eslint-disable no-undef */
// This service worker is processed by workbox-cli

importScripts(
  'https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js',
);

// Configure workbox
workbox.setConfig({
  debug: false,
});

// Track caching progress
let cachingComplete = false;

// Add proper content type headers for service worker
self.addEventListener('install', (event) => {
  // Perform install steps and notify when complete
  event.waitUntil(
    caches.open('app-cache').then(() => {
      self.skipWaiting();
      // After installation is complete, notify clients
      setTimeout(() => {
        if (!cachingComplete) {
          cachingComplete = true;
          self.clients.matchAll().then((clients) => {
            clients.forEach((client) => {
              client.postMessage({
                type: 'CACHING_COMPLETE',
                message: 'All assets have been cached for offline use',
              });
            });
          });
        }
      }, 3000);
    }),
  );
});

self.addEventListener('activate', (event) => {
  event.waitUntil(clients.claim());
});

// Add message handler for caching progress
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'CACHING_COMPLETE') {
    cachingComplete = true;
    // Notify all clients that caching is complete
    self.clients.matchAll().then((clients) => {
      clients.forEach((client) => {
        client.postMessage({
          type: 'CACHING_COMPLETE',
          message: 'All assets have been cached for offline use',
        });
      });
    });
  }
});

const { registerRoute } = workbox.routing;
const { CacheFirst, StaleWhileRevalidate, NetworkFirst } = workbox.strategies;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute } = workbox.precaching;
const { BackgroundSyncPlugin } = workbox.backgroundSync;

// Precache all assets generated by your build process
// Note: precacheAndRoute doesn't return a Promise, so we can't chain .then()
precacheAndRoute(self.__WB_MANIFEST);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
// Your app uses Amiri and Tajawal fonts from Google
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  }),
);

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365,
        maxEntries: 30,
      }),
    ],
  }),
);

// Cache all assets in the assets folder and its subfolders
registerRoute(
  ({ request }) =>
    request.url.includes('/assets/') ||
    request.url.includes('/icons/') ||
    request.url.includes('/splash/'),
  new CacheFirst({
    cacheName: 'app-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 2000, // Increased to handle more assets
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  }),
);

// Specific cache for Quran page images
registerRoute(
  ({ request }) =>
    request.destination === 'image' &&
    (request.url.includes('/images/') || request.url.includes('/mushaf-data/')),
  new CacheFirst({
    cacheName: 'quran-images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 1000,
        maxAgeSeconds: 30 * 24 * 60 * 60,
      }),
    ],
  }),
);

// Cache AsyncStorage data with a StaleWhileRevalidate strategy
// Your app uses AsyncStorage for user preferences
registerRoute(
  ({ url }) => url.pathname.includes('AsyncStorage'),
  new StaleWhileRevalidate({
    cacheName: 'async-storage-data',
  }),
);

// Background sync for reading position
const readingPositionSyncPlugin = new BackgroundSyncPlugin(
  'reading-position-queue',
  {
    maxRetentionTime: 24 * 60, // Retry for up to 24 hours (in minutes)
  },
);

// Register route for syncing reading position
registerRoute(
  ({ url }) => url.pathname.includes('currentSavedPage'),
  new NetworkFirst({
    cacheName: 'reading-position',
    plugins: [readingPositionSyncPlugin],
  }),
  'POST',
);

// Default strategy for all other requests
registerRoute(
  ({ request }) =>
    request.destination === 'script' || request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  }),
);

// Handle offline fallback
const networkFirstHandler = new NetworkFirst();
const navigationHandler = async (params) => {
  try {
    return await networkFirstHandler.handle(params);
  } catch {
    // Return cached home page as fallback when offline
    const cache = await caches.open('pages-cache');
    const cachedResponse = await cache.match('/');
    return cachedResponse || caches.match('/offline.html');
  }
};

registerRoute(({ request }) => request.mode === 'navigate', navigationHandler);
