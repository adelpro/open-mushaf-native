/* eslint-disable no-undef */
// This service worker is processed by workbox-cli

importScripts(
  'https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js',
);

// Configure workbox
workbox.setConfig({
  debug: false,
});

// Add proper content type headers for service worker
self.addEventListener('install', (event) => {
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(clients.claim());
});

const { registerRoute } = workbox.routing;
const { CacheFirst, StaleWhileRevalidate, NetworkFirst } = workbox.strategies;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute } = workbox.precaching;
const { BackgroundSyncPlugin } = workbox.backgroundSync;

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
// Your app uses Amiri and Tajawal fonts from Google
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  }),
);

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365,
        maxEntries: 30,
      }),
    ],
  }),
);

// Cache Quran page images with a cache-first strategy
// This is specific to your app's Quran pages
registerRoute(
  ({ request }) =>
    (request.destination === 'image' && request.url.includes('/images/')) ||
    request.url.includes('/mushaf-data/') ||
    new CacheFirst({
      cacheName: 'quran-images',
      plugins: [
        new ExpirationPlugin({
          maxEntries: 1000,
          maxAgeSeconds: 30 * 24 * 60 * 60,
        }),
      ],
    }),
);

// Cache AsyncStorage data with a StaleWhileRevalidate strategy
// Your app uses AsyncStorage for user preferences
registerRoute(
  ({ url }) => url.pathname.includes('AsyncStorage'),
  new StaleWhileRevalidate({
    cacheName: 'async-storage-data',
  }),
);

// Background sync for reading position
const readingPositionSyncPlugin = new BackgroundSyncPlugin(
  'reading-position-queue',
  {
    maxRetentionTime: 24 * 60, // Retry for up to 24 hours (in minutes)
  },
);

// Register route for syncing reading position
registerRoute(
  ({ url }) => url.pathname.includes('currentSavedPage'),
  new NetworkFirst({
    cacheName: 'reading-position',
    plugins: [readingPositionSyncPlugin],
  }),
  'POST',
);

// Default strategy for all other requests
registerRoute(
  ({ request }) =>
    request.destination === 'script' || request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  }),
);

// Handle offline fallback
const networkFirstHandler = new NetworkFirst();
const navigationHandler = async (params) => {
  try {
    return await networkFirstHandler.handle(params);
  } catch {
    // Return cached home page as fallback when offline
    const cache = await caches.open('pages-cache');
    const cachedResponse = await cache.match('/');
    return cachedResponse || caches.match('/offline.html');
  }
};

registerRoute(({ request }) => request.mode === 'navigate', navigationHandler);
